<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Front Path Drawer</title>
<style>
body { margin: 0; overflow: hidden; font-family: sans-serif; }

/* ------------------ NEW MAP CONTAINER STYLES ------------------ */

#mapContainer {
    position: absolute; 
    top: 50px; 
    left: 50%;
    transform: translateX(-50%); 
    width: 80vw; /* Initial size of the visible map area */
    height: 80vh; 
    border: 1px solid #ccc;
    box-shadow: 0 0 10px rgba(0,0,0,0.5);
    overflow: auto; 
    background: #f0f0f0; 
    
    /* RE-ADDED: Allows CSS resizing */
    resize: both; 
    
    min-width: 300px;
    min-height: 200px;
    z-index: 50; 
}

/* Draggable handle for the map container */
#dragHandle {
    position: sticky; /* Make the handle stick to the top when scrolling the map content */
    top: 0;
    left: 0;
    width: 100%;
    height: 20px; 
    background: #555;
    color: white;
    font-size: 12px;
    line-height: 20px;
    text-align: center;
    cursor: grab; 
    z-index: 51; 
    user-select: none; 
}

/* The map image itself */
#mapContainer img {
    display: none; 
    /* CHANGED: Make the image fill the container space, allowing it to scale */
    width: 100%; 
    height: auto; 
    position: relative; /* Changed from absolute to flow better below sticky handle */
    top: 0;
    left: 0;
    /* Ensure image content doesn't affect drawing coordinates */
    pointer-events: none; 
}

/* The SVG overlay must match the exact size of the image/map */
#canvas {
    position: absolute;
    top: 20px; /* Offset by handle height */
    left: 0;
    /* IMPORTANT: Make the SVG match the image's (and therefore the container's) width/height */
    width: 100%; 
    height: calc(100% - 20px); /* Fill the remaining height */
    cursor: crosshair; 
    background: transparent !important; 
    display: block; 
}

/* ------------------ TOOLBAR STYLES (Unchanged) ------------------ */

#toolbar { 
    position: fixed; 
    top: 10px; 
    left: 10px; 
    background: white; 
    padding: 10px; 
    border-radius: 6px; 
    box-shadow: 0 2px 5px rgba(0,0,0,0.2); 
    z-index: 100; 
    display: grid;
    grid-template-columns: repeat(4, auto);
    gap: 8px; 
    transition: width 0.3s ease, height 0.3s ease, padding 0.3s ease, transform 0.3s ease;
}
#toolbar button, #toolbar label { 
    margin: 0; 
    padding: 8px 10px; 
    white-space: nowrap;
    text-align: center;
    cursor: pointer;
    border: 1px solid #ccc; 
    border-radius: 4px;
    background: #f8f8f8;
    box-shadow: 0 1px 1px rgba(0,0,0,0.05);
    min-width: 0; 
    transition: opacity 0.3s ease, visibility 0.3s ease;
}

/* Hide the actual file input */
#fileInput {
    display: none;
}

/* ------------------ MINIMIZE/MAXIMIZE CSS (Unchanged) ------------------ */

#toggleBtn {
    position: absolute;
    top: 0;
    right: 0;
    width: 28px;
    height: 28px;
    padding: 0;
    background: #f00; 
    color: white;
    border: none;
    border-radius: 0 6px 0 6px;
    line-height: 1;
    font-size: 14px;
    font-weight: bold;
    cursor: pointer;
    box-shadow: none; 
    z-index: 101; 
    transition: background 0.3s ease;
}

#toolbar.minimized {
    width: 38px; 
    height: 38px; 
    padding: 5px; 
    overflow: hidden;
    display: block; 
}

#toolbar.minimized > * {
    opacity: 0;
    visibility: hidden;
    pointer-events: none; 
    transition: opacity 0.3s ease, visibility 0.3s ease;
}

#toolbar.minimized #toggleBtn {
    opacity: 1;
    visibility: visible;
    pointer-events: auto;
    background: #090; 
    border-radius: 6px; 
    width: 28px;
    height: 28px;
    top: 5px;
    right: 5px;
    transform: none; 
}

#toolbar:not(.minimized) {
    display: grid;
}

/* ------------------ BANNER (Unchanged) ------------------ */

#selected-front-banner {
    position: fixed; 
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    background: #444; 
    color: white;
    padding: 8px 15px;
    border-radius: 6px;
    font-size: 16px;
    font-weight: bold;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    opacity: 0;
    visibility: hidden;
    transition: all 0.3s ease-in-out;
    z-index: 99;
}
#selected-front-banner.show {
    opacity: 1;
    visibility: visible;
}
</style>
</head>
<body>

<div id="toolbar">
  <button id="toggleBtn" title="Minimize/Maximize" style="grid-column: span 4; text-align: right;">X</button>
  
  <button id="coldBtn">Cold Front</button>
  <button id="warmBtn">Warm Front</button>
  <button id="drylineBtn">Dryline</button>
  <button id="stationaryBtn">Stationary Front</button>
  
  <button id="occludedBtn">Occluded Front</button>
  <button id="troughBtn">Trough</button>
  <button id="lowBtn" style="color: red; font-weight: bold;">Low (L)</button>
  <button id="highBtn" style="color: blue; font-weight: bold;">High (H)</button>
  
  <button id="undoBtn">Undo</button>
  <button id="eraseBtn">Erase All</button>
  
  <input type="file" id="fileInput" accept="image/*" />
  <label for="fileInput" id="loadMapLabel">Load Map</label>
  
  <button id="downloadBtn" style="background: #e6e6e6; font-weight: bold;">Download Map (SVG)</button>
  
</div>

<div id="selected-front-banner">Selected: <span id="current-front-name">Cold Front</span></div>

<div id="mapContainer">
    <div id="dragHandle">Drag Map Here</div>
    
    <svg id="canvas">
        <defs>
            <g id="coldFrontSymbol" fill="blue" stroke="blue" stroke-width="3">
                <path d="M 0 -20 L 0 5" stroke="blue" stroke-width="3" fill="none"/>
                <path d="M 0,-15 L 0,15 L 25,0 Z"/>
            </g>
            <g id="warmFrontSymbol" fill="red" stroke="red" stroke-width="3">
                <path d="M 0 -20 L 0 5" stroke="red" stroke-width="3" fill="none"/>
                <path d="M 0,-15 A 15,15 0 0,1 0,15 Z"/>
            </g>
            <g id="DrylineFrontSymbol" fill="none" stroke="brown" stroke-width="3">
                <path d="M 0,-15 A 15,15 0 0,1 0,15 Z"/>
            </g>
            
            <g id="stationaryFrontSymbol" fill="none" stroke-width="3">
                <path d="M 0 -20 L 0 5" stroke="blue" stroke-width="3" fill="none"/>
                <path d="M 0 0 L 0 35" stroke="red" stroke-width="5" fill="none"/>
                <path d="M 0,-15 L 10,-10 L 0,-5 Z" fill="blue" stroke="blue"/>
                <path d="M 0,5 A 5,5 0 1,0 0,25" fill="red" stroke="red" />
            </g>
            
            <g id="occludedFrontSymbol" fill="none" stroke="purple" stroke-width="3">
                <path d="M 0 -20 L 0 20" stroke="purple" stroke-width="3" fill="none"/>
                <path d="M 0,-15 L 10,-10 L 0,-5 Z" fill="purple" stroke="purple"/>
                <path d="M 0,0 A 5,5 0 0,0 0,15" fill="purple" stroke="purple" transform="translate(-0, 15) rotate(-180)"/>
            </g>
            
            <text id="lowPressureSymbol" x="0" y="0" font-size="30" font-weight="bold" fill="red" text-anchor="middle" dominant-baseline="central">L</text>
            <text id="highPressureSymbol" x="0" y="0" font-size="30" font-weight="bold" fill="blue" text-anchor="middle" dominant-baseline="central">H</text>

        </defs>
    </svg>
</div>

<script>
const svg = document.getElementById("canvas");
const mapContainer = document.getElementById("mapContainer");
const dragHandle = document.getElementById("dragHandle");
const fileInput = document.getElementById("fileInput");
const downloadBtn = document.getElementById("downloadBtn");
const toolbar = document.getElementById("toolbar");
const toggleBtn = document.getElementById("toggleBtn");

const HANDLE_HEIGHT = 20; // Define the height of the drag handle

let currentMapImage = null; 
let drawing = false;
let currentSymbol = "coldFrontSymbol";

const banner = document.getElementById('selected-front-banner');
const frontNameSpan = document.getElementById('current-front-name');

const frontDisplayNames = {
    "coldFrontSymbol": "Cold Front",
    "warmFrontSymbol": "Warm Front",
    "DrylineFrontSymbol": "Dryline",
    "stationaryFrontSymbol": "Stationary Front",
    "occludedFrontSymbol": "Occluded Front",
    "trough": "Trough",
    "low": "Low Pressure (L)",
    "high": "High Pressure (H)"
};

// ... (Functions updateBanner, setFront, Toolbar switching, Erase, Minimize/Maximize logic are unchanged) ...

function updateBanner(symbolId) {
    const displayName = frontDisplayNames[symbolId] || "Unknown Front";
    frontNameSpan.textContent = displayName;
    
    banner.classList.add('show');
    clearTimeout(banner.hideTimeout);
    banner.hideTimeout = setTimeout(() => {
        banner.classList.remove('show');
    }, 2000); 
}

function setFront(symbolId) {
    currentSymbol = symbolId;
    updateBanner(symbolId);
}

updateBanner(currentSymbol);

document.getElementById("coldBtn").addEventListener("click", () => setFront("coldFrontSymbol"));
document.getElementById("warmBtn").addEventListener("click", () => setFront("warmFrontSymbol"));
document.getElementById("drylineBtn").addEventListener("click", () => setFront("DrylineFrontSymbol"));
document.getElementById("stationaryBtn").addEventListener("click", () => setFront("stationaryFrontSymbol"));
document.getElementById("occludedBtn").addEventListener("click", () => setFront("occludedFrontSymbol"));
document.getElementById("troughBtn").addEventListener("click", () => setFront("trough"));
document.getElementById("lowBtn").addEventListener("click", () => setFront("low"));
document.getElementById("highBtn").addEventListener("click", () => setFront("high"));

document.getElementById("eraseBtn").addEventListener("click", () => {
    svg.querySelectorAll("g.frontGroup").forEach(el => el.remove());
    svg.querySelectorAll("text.pressureCenter").forEach(el => el.remove());
});

toggleBtn.addEventListener('click', () => {
    toolbar.classList.toggle('minimized');
    if (toolbar.classList.contains('minimized')) {
        toggleBtn.textContent = '+'; 
    } else {
        toggleBtn.textContent = 'X'; 
    }
});

// === DRAGGABLE LOGIC (Unchanged, operates on mapContainer) ===
let isDragging = false;
let offsetX, offsetY;

dragHandle.addEventListener('mousedown', (e) => {
    isDragging = true;
    const rect = mapContainer.getBoundingClientRect();
    offsetX = e.clientX - rect.left;
    offsetY = e.clientY - rect.top;
    
    dragHandle.style.cursor = 'grabbing';
    e.preventDefault(); 
});

document.addEventListener('mousemove', (e) => {
    if (!isDragging) return;

    let newX = e.clientX - offsetX;
    let newY = e.clientY - offsetY;

    mapContainer.style.left = `${newX}px`;
    mapContainer.style.top = `${newY}px`;
    
    // Crucial: remove initial centering transform property
    mapContainer.style.transform = 'none'; 
});

document.addEventListener('mouseup', () => {
    if (isDragging) {
        isDragging = false;
        dragHandle.style.cursor = 'grab';
    }
});
// =============================


// === UPDATED IMAGE UPLOAD LOGIC for RESIZING ===
fileInput.addEventListener("change", (e) => {
    const file = e.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (event) => {
            if (currentMapImage) {
                currentMapImage.remove();
            }

            currentMapImage = document.createElement('img');
            currentMapImage.src = event.target.result;
            currentMapImage.style.display = 'block'; 
            currentMapImage.id = 'mapImage'; 

            // Insert image element before the SVG canvas
            mapContainer.insertBefore(currentMapImage, svg);
            
            currentMapImage.onload = () => {
                const width = currentMapImage.naturalWidth;
                const height = currentMapImage.naturalHeight;
                
                // 1. Set the map container's size to the image's original size + handle height.
                // This ensures the initial view shows the map unscaled (1:1 pixel ratio).
                mapContainer.style.width = `${width}px`;
                mapContainer.style.height = `${height + HANDLE_HEIGHT}px`;

                // 2. The image and SVG inside already use width: 100% and height: calc(100% - 20px) 
                // so they will automatically scale if the user uses the CSS resize handle.
                
                // 3. Set the SVG viewBox to the original image dimensions.
                // This is the key that allows the vector drawings to scale with the SVG element.
                svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
            };
        };
        reader.readAsDataURL(file);
    }
});
// =============================

// ... (SVG Download and Drawing Logic remain the same) ...

downloadBtn.addEventListener("click", () => {
    if (!currentMapImage) {
        alert("Please load a map image first before downloading.");
        return;
    }
    
    // Get the viewBox dimensions, which represent the original map coordinates
    const viewBox = svg.getAttribute('viewBox').split(' ').map(Number);
    const width = viewBox[2];
    const height = viewBox[3];

    // Create a temporary image element for the exported SVG file
    const background_image_for_svg = document.createElementNS("http://www.w3.org/2000/svg", "image");
    background_image_for_svg.setAttribute("href", currentMapImage.src);
    
    // Set size based on the original viewBox dimensions for the exported file
    background_image_for_svg.setAttribute("width", width);
    background_image_for_svg.setAttribute("height", height);
    background_image_for_svg.setAttribute("x", 0);
    background_image_for_svg.setAttribute("y", 0);
    
    svg.prepend(background_image_for_svg); 
    
    const serializer = new XMLSerializer();
    let source = serializer.serializeToString(svg);
    
    // Use the viewBox dimensions for the output SVG header
    source = source.replace('<svg', 
        `<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg"`);
    
    if (!source.match(/^<\?xml/)) {
        source = '<?xml xml version="1.0" standalone="no"?>\r\n' + source;
    }

    background_image_for_svg.remove(); 

    const url = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(source);
    
    const downloadLink = document.createElement("a");
    downloadLink.href = url;
    downloadLink.download = "weather_map_with_background.svg"; 

    document.body.appendChild(downloadLink);
    downloadLink.click();
    document.body.removeChild(downloadLink);
});


// Current path info
let pathData = "";
let currentPathGroup = null;

svg.addEventListener("mousedown", e => {
    // Check if the click is on the drag handle
    if (e.target.id === 'dragHandle') return;
    
    drawing = false; 

    // The coordinates e.offsetX/Y are relative to the SVG, 
    // and since the SVG uses a viewBox based on the original image size, 
    // the drawing coordinates are automatically scaled correctly.

    if (currentSymbol === "low" || currentSymbol === "high") {
        const use = document.createElementNS("http://www.w3.org/2000/svg", "use");
        const symbolId = currentSymbol === "low" ? "lowPressureSymbol" : "highPressureSymbol";
        
        use.setAttribute("href", `#${symbolId}`);
        use.setAttribute("x", e.offsetX);
        use.setAttribute("y", e.offsetY);
        use.classList.add("pressureCenter"); 
        
        const pressureGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
        pressureGroup.classList.add("frontGroup"); 
        pressureGroup.appendChild(use);
        svg.appendChild(pressureGroup);

    } else {
        drawing = true;
        pathData = `M${e.offsetX},${e.offsetY}`;

        currentPathGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
        currentPathGroup.classList.add("frontGroup");
        svg.appendChild(currentPathGroup);

        const newPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
        newPath.setAttribute("d", pathData);
        newPath.setAttribute("fill", "none");
        newPath.setAttribute("stroke-width", 5);

        let strokeColor = "blue";
        let useSymbols = true;
        let strokeDash = "none";

        if (currentSymbol === "warmFrontSymbol") strokeColor = "red";
        else if (currentSymbol === "DrylineFrontSymbol") strokeColor = "brown";
        else if (currentSymbol === "occludedFrontSymbol") strokeColor = "purple";
        else if (currentSymbol === "trough") {
            strokeColor = "black";
            strokeDash = "45, 40";
            useSymbols = false;
        }

        newPath.setAttribute("stroke", strokeColor);
        newPath.setAttribute("stroke-dasharray", strokeDash);
        currentPathGroup.appendChild(newPath);

        if (useSymbols) {
            const symbolsGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
            currentPathGroup.appendChild(symbolsGroup);
            currentPathGroup.symbolsGroup = symbolsGroup;
        } else {
            currentPathGroup.symbolsGroup = null;
        }
        
        currentPathGroup.path = newPath;
        currentPathGroup.symbolId = currentSymbol;
    }
});

svg.addEventListener("mousemove", e => {
    if (!drawing) return;
    
    if (currentSymbol !== "low" && currentSymbol !== "high") {
        pathData += ` L${e.offsetX},${e.offsetY}`;
        currentPathGroup.path.setAttribute("d", pathData);
        
        if (currentPathGroup.symbolsGroup) {
            placeSymbols(currentPathGroup.path, currentPathGroup.symbolsGroup, currentPathGroup.symbolId);
        }
    }
});

svg.addEventListener("mouseup", () => { drawing = false; });

function placeSymbols(path, symbolsGroup, symbolId) {
    symbolsGroup.innerHTML = "";
    const pathLength = path.getTotalLength();

    let spacing = 60;
    if (symbolId === "DrylineFrontSymbol") spacing = 30;
    else if (symbolId === "occludedFrontSymbol") spacing =50;
    else spacing =60;

    for (let dist = 0; dist < pathLength; dist += spacing) {
        const pt = path.getPointAtLength(dist);
        const pt2 = path.getPointAtLength(Math.min(dist + 0.1, pathLength));
        let angle = Math.atan2(pt2.y - pt.y, pt2.x - pt.x) * 180 / Math.PI;
        angle -= 90;

        const use = document.createElementNS("http://www.w3.org/2000/svg","use");
        use.setAttribute("href", `#${symbolId}`); 
        use.setAttribute("transform", `translate(${pt.x},${pt.y}) rotate(${angle})`);
        symbolsGroup.appendChild(use);
    }
}

document.getElementById("undoBtn").addEventListener("click", () => {
    const allGroups = svg.querySelectorAll("g.frontGroup");
    if (allGroups.length > 0) {
        allGroups[allGroups.length - 1].remove();
    }
});
</script>
</body>
</html>