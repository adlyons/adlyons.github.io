<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=1920, height=1080"/>
  <title>Live Weather Dashboard</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 1920px;
      height: 1080px;
      background: transparent;
      overflow: hidden;
    }
    #container {
      position: fixed;
      bottom: 20px;
      left: 20px;
      width: 480px;
      height: 320px;
      display: flex;
      flex-direction: column;
      border: 4px solid black;
      background-color: rgba(255,255,255,0.8);
      transition: background-color 0.5s ease;
      z-index: 1000;
    }
    #map {
      flex: 1;
      border-bottom: 4px solid black;
    }
    #info {
      padding: 8px;
      font-family: Arial, sans-serif;
      font-size: 16px;
      text-align: left;
    }
    #clock {
      position: fixed;
      bottom: 360px;
      left: 20px;
      padding: 8px 12px;
      border: 4px solid black;
      background-color: rgba(255,255,255,0.8);
      font-family: Arial, sans-serif;
      font-size: 20px;
      z-index: 1001;
      transition: background-color 0.5s ease;
    }
  </style>
</head>
<body>
  <div id="clock">Loading clock...</div>
  <div id="container">
    <div id="map"></div>
    <div id="info">Loading location info...</div>
  </div>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    let map, marker, radarLayer, wwaLayer, countyLayer;
    let radarMode = "sr_bref";
    let radarSwitchTimer, zoomOutTimer;

    function updateClock() {
      const now = new Date();
      const localTime = now.toLocaleTimeString();
      const utcTime = now.toUTCString().split(" ")[4];
      document.getElementById("clock").textContent = `Local: ${localTime} | UTC: ${utcTime}`;
    }
    setInterval(updateClock, 1000);
    updateClock();

    function calculateBearing(lat1, lon1, lat2, lon2) {
      const toRad = deg => deg * Math.PI / 180;
      const toDeg = rad => rad * 180 / Math.PI;
      const dLon = toRad(lon2 - lon1);
      const y = Math.sin(dLon) * Math.cos(toRad(lat2));
      const x = Math.cos(toRad(lat1)) * Math.sin(toRad(lat2)) -
                Math.sin(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.cos(dLon);
      const brng = Math.atan2(y, x);
      const compass = (toDeg(brng) + 360) % 360;
      const dirs = ["N","NE","E","SE","S","SW","W","NW"];
      return dirs[Math.round(compass/45)%8];
    }

    async function getWeatherInfo(lat, lon) {
      const alertsResp = await fetch(`https://api.weather.gov/alerts/active?point=${lat},${lon}`);
      const alertsData = await alertsResp.json();

      let bgColor = "rgba(255,255,255,0.8)";
      let alertText = "No active severe alerts.";

      if (alertsData.features.length > 0) {
        // prioritize warnings over watches
        let priority = 0;
        for (const alert of alertsData.features) {
          const event = alert.properties.event;
          if (event.includes("Flash Flood Warning")) {
            bgColor = "green"; alertText = event; priority = 0;
          }
          else if (event.includes("Tornado Warning") && priority < 4) {
            bgColor = "magenta"; alertText = event; priority = 3;
          }
          else if (event.includes("Severe Thunderstorm Warning") && priority < 3) {
            bgColor = "orange"; alertText = event; priority = 2;
          }
          else if (event.includes("Tornado Watch") && priority < 2) {
            bgColor = "yellow"; alertText = event; priority = 1;
          }
          else if (event.includes("Severe Thunderstorm Watch") && priority < 1) {
            bgColor = "pink"; alertText = event; priority = 1;
          }
        }
      }
      document.getElementById("container").style.backgroundColor = bgColor;
      document.getElementById("clock").style.backgroundColor = bgColor;

      const pointsResp = await fetch(`https://api.weather.gov/points/${lat},${lon}`);
      const pointsData = await pointsResp.json();
      const city = pointsData.properties.relativeLocation.properties.city;
      const state = pointsData.properties.relativeLocation.properties.state;

      const countyUrl = pointsData.properties.county;
      let countyName = "Unknown";
      try {
        const countyResp = await fetch(countyUrl);
        if (countyResp.ok) {
          const countyData = await countyResp.json();
          countyName = countyData.properties.name;
        }
      } catch(e) {
        console.warn("county fetch error", e);
      }

      const radarStation = pointsData.properties.radarStation.toLowerCase();
      if (radarLayer) map.removeLayer(radarLayer);
      radarLayer = L.tileLayer.wms(
        `https://opengeo.ncep.noaa.gov/geoserver/${radarStation}/wms`,
        {
          layers: `${radarStation}_${radarMode}`,
          format: "image/png",
          transparent: true,
          attribution: "NOAA/NWS",
          opacity: 0.73,
          version: "1.3.0"
        }
      ).addTo(map);

      const cityCoords = pointsData.properties.relativeLocation.geometry.coordinates;
      const distKm = distance(lat, lon, cityCoords[1], cityCoords[0]);
      const distMi = (distKm * 0.621371).toFixed(1);
      const direction = calculateBearing(cityCoords[1], cityCoords[0], lat, lon);

      let alertStyle = "";
      if (alertText.includes("Tornado Warning") || alertText.includes("Severe Thunderstorm Warning")) {
        alertStyle = 'font-weight: bold; font-size: 21px;'; // 16 + 5 px
      }


      document.getElementById("info").innerHTML = `
        <strong>Nearest City:</strong> ${city}, ${state} <br>
        <strong>County:</strong> ${countyName} <br>
        <strong>Distance/Direction:</strong> ${distMi} mi ${direction} <br>
        <strong style="${alertStyle}">Alert:</strong> <span style="${alertStyle}">${alertText}</span>
      `;
    }


    function distance(lat1, lon1, lat2, lon2) {
      const R = 6371;
      const dLat = (lat2 - lat1) * Math.PI/180;
      const dLon = (lon2 - lon1) * Math.PI/180;
      const a =
        Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(lat1*Math.PI/180) * Math.cos(lat2*Math.PI/180) *
        Math.sin(dLon/2) * Math.sin(dLon/2);
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    function setup() {
      if (!navigator.geolocation) {
        alert("Geolocation not supported.");
        return;
      }
      navigator.geolocation.watchPosition(async pos => {
        const lat = pos.coords.latitude;
        const lon = pos.coords.longitude;
        
        if (!map) {
          map = L.map('map', { zoomControl: false }).setView([lat, lon], 10);

          // custom car icon
          const carIcon = L.icon({
            iconUrl: "https://cdn-icons-png.flaticon.com/512/5952/5952510.png",
            iconSize: [40,40],
            iconAnchor: [16,16]
          });
          marker = L.marker([lat, lon], {icon: carIcon}).addTo(map);

          // OSM basemap
          L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
            attribution: "Â© OpenStreetMap contributors"
          }).addTo(map);

          // create a pane with highest z-index for warnings
          map.createPane("warningsPane");
          map.getPane("warningsPane").style.zIndex = 650;

          // WWA overlay from NOAA MapServer
          wwaLayer = L.tileLayer.wms(
            "https://mapservices.weather.noaa.gov/eventdriven/services/WWA/watch_warn_adv/MapServer/WMSServer",
            {
              layers: "1",
              format: "image/png",
              transparent: true,
              attribution: "NOAA/NWS",
              version: "1.3.0",
              pane: "warningsPane"
            }
          ).addTo(map);

          // counties geojson
          fetch("https://raw.githubusercontent.com/plotly/datasets/master/geojson-counties-fips.json")
            .then(r => r.json())
            .then(countyData => {
              countyLayer = L.geoJSON(countyData, {
                style: {
                  color: "black",
                  weight: 0.5,
                  fillOpacity: 0
                }
              }).addTo(map);
            });
        } else {
          marker.setLatLng([lat, lon]);
          map.setView([lat, lon]);
        }

        await getWeatherInfo(lat, lon);
      }, console.error, { enableHighAccuracy: true });

      // switch radar product every 5 min
      radarSwitchTimer = setInterval(() => {
        radarMode = (radarMode === "sr_bref") ? "sr_bvel" : "sr_bref";
      }, 1 * 60 * 1000);

      // wide zoom for 30 sec every 10 min
      setInterval(() => {
        if(map) {
          const current = map.getCenter();
          map.setZoom(7);
          zoomOutTimer = setTimeout(() => {
            map.setView(current, 10);
          }, 30 * 1000);
        }
      }, 5 * 60 * 1000);
    }

      setInterval(() => {
        location.reload();
          }, 5 * 60 * 1000);


    setup();
  </script>
</body>
</html>
