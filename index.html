<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=1920, height=1080"/>
<title>Live Weather Dashboard</title>
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
/>
<style>
  html, body {
    margin: 0; padding: 0;
    width: 1920px; height: 1080px;
    background: transparent;
    overflow: hidden;
  }
  #clock {
    position: fixed;
    bottom: 360px;
    left: 20px;
    padding: 8px 12px;
    border: 4px solid black;
    background-color: rgba(255,255,255,0.8);
    font-family: Arial, sans-serif;
    font-size: 20px;
    z-index: 1001;
  }
  #container {
    position: fixed;
    bottom: 20px;
    left: 20px;
    width: 384px; /* shrunk by 20% from 480 */
    height: 256px; /* shrunk by 20% from 320 */
    display: flex;
    flex-direction: column;
    border: 4px solid black;
    background-color: rgba(255,255,255,0.8);
    transition: background-color 0.5s ease;
    z-index: 1000;
  }
  #map {
    flex: 1;
    border-bottom: 4px solid black;
  }
  #info {
    padding: 8px;
    font-family: Arial, sans-serif;
    font-size: 16px;
    text-align: left;
  }
</style>
</head>
<body>
  <div id="clock">Loading clock...</div>
  <div id="container">
    <div id="map"></div>
    <div id="info">Loading location info...</div>
  </div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
  let map, marker, radarLayer, warningsLayer, countiesLayer;

  function updateClock() {
    const now = new Date();
    const localTime = now.toLocaleTimeString();
    const utcTime = now.toUTCString().split(" ")[4];
    document.getElementById("clock").textContent = `Local: ${localTime} | UTC: ${utcTime}`;
  }
  setInterval(updateClock, 1000);
  updateClock();

  function calculateBearing(lat1, lon1, lat2, lon2) {
    const toRad = deg => deg * Math.PI / 180;
    const toDeg = rad => rad * 180 / Math.PI;
    const dLon = toRad(lon2 - lon1);
    const y = Math.sin(dLon) * Math.cos(toRad(lat2));
    const x = Math.cos(toRad(lat1)) * Math.sin(toRad(lat2)) -
              Math.sin(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.cos(dLon);
    const brng = Math.atan2(y, x);
    const compass = (toDeg(brng) + 360) % 360;
    const dirs = ["N","NE","E","SE","S","SW","W","NW"];
    return dirs[Math.round(compass/45)%8];
  }

  function distance(lat1, lon1, lat2, lon2) {
    const R = 6371; // km
    const dLat = (lat2 - lat1) * Math.PI/180;
    const dLon = (lon2 - lon1) * Math.PI/180;
    const a =
      Math.sin(dLat/2) * Math.sin(dLat/2) +
      Math.cos(lat1*Math.PI/180) * Math.cos(lat2*Math.PI/180) *
      Math.sin(dLon/2) * Math.sin(dLon/2);
    return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  }

  async function getNearestRadar(lat, lon) {
    // Query NWS api for radar sites near point
    const resp = await fetch(`https://api.weather.gov/radars/locations`);
    const data = await resp.json();
    if (!data.features) return null;

    let minDist = Infinity;
    let nearestSite = null;
    data.features.forEach(f => {
      const [rLon, rLat] = f.geometry.coordinates;
      const d = distance(lat, lon, rLat, rLon);
      if (d < minDist) {
        minDist = d;
        nearestSite = f.properties.stationIdentifier;
      }
    });
    return nearestSite;
  }

  async function getWeatherInfo(lat, lon) {
    // Get active alerts for point
    const alertsResp = await fetch(`https://api.weather.gov/alerts/active?point=${lat},${lon}`);
    const alertsData = await alertsResp.json();

    let bgColor = "rgba(255,255,255,0.8)";
    let alertText = "No active severe alerts.";

    if (alertsData.features && alertsData.features.length > 0) {
      const firstAlert = alertsData.features[0];
      const event = firstAlert.properties.event;
      if (event.includes("Tornado Warning")) bgColor = "red";
      else if (event.includes("Severe Thunderstorm Warning")) bgColor = "yellow";
      else if (event.includes("Tornado Watch")) bgColor = "pink";
      else if (event.includes("Severe Thunderstorm Watch")) bgColor = "blue";
      alertText = event;
    }
    document.getElementById("container").style.backgroundColor = bgColor;

    // Get nearest city and county
    const pointsResp = await fetch(`https://api.weather.gov/points/${lat},${lon}`);
    const pointsData = await pointsResp.json();

    if (!pointsData.properties || !pointsData.properties.relativeLocation) {
      document.getElementById("info").textContent = "Location info unavailable";
      return;
    }
    const city = pointsData.properties.relativeLocation.properties.city;
    const state = pointsData.properties.relativeLocation.properties.state;
    const countyUrl = pointsData.properties.county;

    const countyResp = await fetch(countyUrl);
    const countyData = await countyResp.json();
    const countyName = countyData.properties.name;

    const cityCoords = pointsData.properties.relativeLocation.geometry.coordinates;
    const distKm = distance(lat, lon, cityCoords[1], cityCoords[0]);
    const distMi = (distKm * 0.621371).toFixed(1);
    const direction = calculateBearing(cityCoords[1], cityCoords[0], lat, lon);

    document.getElementById("info").innerHTML = `
      <strong>Nearest City:</strong> ${city}, ${state} <br>
      <strong>County:</strong> ${countyName} <br>
      <strong>Distance/Direction:</strong> ${distMi} mi ${direction} <br>
      <strong>Alert:</strong> ${alertText}
    `;
  }

  async function setup() {
    if (!navigator.geolocation) {
      alert("Geolocation not supported.");
      return;
    }
    navigator.geolocation.watchPosition(async pos => {
      const lat = pos.coords.latitude;
      const lon = pos.coords.longitude;

      if (!map) {
        map = L.map('map', { zoomControl: false }).setView([lat, lon], 9);
        marker = L.marker([lat, lon]).addTo(map);

        // Add OpenStreetMap base layer
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: 'Â© OpenStreetMap contributors'
        }).addTo(map);

        // Load counties GeoJSON from Iowa State Mesonet public URL
        countiesLayer = L.geoJSON(null, {
          style: {
            color: "#333",
            weight: 1,
            fillOpacity: 0,
          }
        }).addTo(map);

        fetch('https://mesonet.agron.iastate.edu/geojson/cnty2017.geojson')
          .then(r => r.json())
          .then(data => {
            countiesLayer.addData(data);
          });

        // Load warnings WMS from NCEP WWA
        warningsLayer = L.tileLayer.wms("https://opengeo.ncep.noaa.gov/geoserver/wwa/warnings/ows", {
          layers: "wwa_warnings",
          format: "image/png",
          transparent: true,
          version: "1.3.0",
          attribution: "NOAA/NCEP"
        }).addTo(map);
      } else {
        marker.setLatLng([lat, lon]);
        map.setView([lat, lon]);
      }

      // Update radar layer based on nearest radar site dynamically
      const nearestRadar = await getNearestRadar(lat, lon);
      if (radarLayer) {
        map.removeLayer(radarLayer);
      }
      if (nearestRadar) {
        radarLayer = L.tileLayer.wms(`https://opengeo.ncep.noaa.gov/geoserver/${nearestRadar.toLowerCase()}/wms`, {
          layers: `${nearestRadar.toLowerCase()}_sr_bref`,
          format: 'image/png',
          transparent: true,
          version: '1.3.0',
          attribution: 'NOAA/NWS'
        }).addTo(map);
      }

      await getWeatherInfo(lat, lon);
    }, console.error, { enableHighAccuracy: true });
  }

  setup();
</script>
</body>
</html>
